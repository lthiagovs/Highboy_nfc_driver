/**
 * @file main.c
 * @brief High Boy NFC â€” Flipper Zero-style MIFARE Classic Reader v3.
 *
 * Improvements over v2:
 *   - Shows KNOWN Key A (from auth), not read-back zeros
 *   - Manufacturer ID lookup from block 0 byte 0
 *   - BCC (Block Check Character) verification
 *   - MAD (MIFARE Application Directory) detection
 *   - PRNG nonce analysis (static nonce â†’ clone detection)
 *   - Value block detection and decoding
 *   - Key B extraction from trailer when access bits permit
 *   - Data content classification (empty, data, value block)
 *   - ASCII representation of data blocks
 */
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_timer.h"

#include "highboy_nfc.h"
#include "st25r3916_core.h"
#include "st25r3916_reg.h"
#include "nfc_poller.h"
#include "nfc_common.h"
#include "poller.h"
#include "mf_ultralight.h"
#include "mf_classic.h"
#include "mf_classic_emu.h"
#include "nfc_device.h"
#include "emu_diag.h"
#include "hb_nfc_timer.h"
#include "hb_nfc_spi.h"
#include "esp_task_wdt.h"
#include "nfc_card_info.h"
#include "nfc_reader.h"

static void hex_str(const uint8_t* data, size_t len, char* buf, size_t buf_sz)
{
    size_t pos = 0;
    for (size_t i = 0; i < len && pos + 3 < buf_sz; i++) {
        pos += (size_t)snprintf(buf + pos, buf_sz - pos,
                                "%02X%s", data[i], i + 1 < len ? " " : "");
    }
}

static const char* TAG = "hb_main";

/* Global: card data for emulation (filled during read) */
mfc_emu_card_data_t s_emu_card = { 0 };
bool                s_emu_data_ready = false;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *  Main Application
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *  Emulation Task â€” runs on separate task with WDT unsubscribed
 *
 *  REASON: spi_device_polling_transmit() does internal busy-wait
 *  in spi_hal_usr_is_done(). This holds the CPU for microseconds
 *  per call, but when called in a tight loop (polling for IRQ),
 *  the cumulative time exceeds the WDT timeout (5s).
 *  Running on a separate task that is NOT subscribed to the
 *  task WDT avoids this entirely.
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */


static volatile bool s_emu_running = false;
static volatile bool s_emu_done = false;
static mfc_emu_stats_t s_emu_final_stats;

/* â”€â”€ Emulation event callback for live status â”€â”€ */
static void emu_event_handler(const mfc_emu_event_t* evt, void* ctx)
{
    (void)ctx;
    switch (evt->type) {
    case MFC_EMU_EVT_ACTIVATED:
        ESP_LOGI("emu_cb", "â•”â•â•â• ğŸ¯ READER DETECTOU NÃ“S! â•â•â•â•—");
        break;
    case MFC_EMU_EVT_AUTH_SUCCESS:
        ESP_LOGI("emu_cb", "  âœ“ AUTH OK sector %d Key%c",
                 evt->auth.sector,
                 evt->auth.key_type == MF_KEY_A ? 'A' : 'B');
        break;
    case MFC_EMU_EVT_AUTH_FAIL:
        ESP_LOGW("emu_cb", "  âœ— AUTH FAIL sector %d Key%c",
                 evt->auth.sector,
                 evt->auth.key_type == MF_KEY_A ? 'A' : 'B');
        break;
    case MFC_EMU_EVT_READ:
        ESP_LOGI("emu_cb", "  ğŸ“– READ block %d", evt->read.block);
        break;
    case MFC_EMU_EVT_WRITE:
        ESP_LOGI("emu_cb", "  âœï¸  WRITE block %d", evt->write.block);
        break;
    case MFC_EMU_EVT_WRITE_BLOCKED:
        ESP_LOGW("emu_cb", "  ğŸš« WRITE BLOCKED block %d (access denied)",
                 evt->write.block);
        break;
    case MFC_EMU_EVT_VALUE_OP:
        ESP_LOGI("emu_cb", "  ğŸ’° VALUE OP cmd=0x%02X block=%d val=%ld",
                 evt->value_op.cmd, evt->value_op.block,
                 (long)evt->value_op.value);
        break;
    case MFC_EMU_EVT_HALT:
        ESP_LOGI("emu_cb", "  â¹  HALT recebido");
        break;
    case MFC_EMU_EVT_FIELD_LOST:
        ESP_LOGW("emu_cb", "  ğŸ“¡ Campo perdido â€” aguardando reconexÃ£o...");
        break;
    case MFC_EMU_EVT_ERROR:
        ESP_LOGE("emu_cb", "  âŒ ERRO na emulaÃ§Ã£o");
        break;
    }
}

void emu_task_func(void* arg)
{
    (void)arg;

    ESP_LOGI("emu_task", "Emulation task started");

    /* Unsubscribe from WDT â€” we'll manage our own timing */
    esp_task_wdt_delete(xTaskGetCurrentTaskHandle());

    /* Test SPI health before entering loop */
    uint8_t test_id = 0;
    hb_spi_reg_read(REG_IC_IDENTITY, &test_id);
    ESP_LOGI("emu_task", "Pre-loop SPI test: IC_ID=0x%02X", test_id);
    if (test_id == 0x00 || test_id == 0xFF) {
        ESP_LOGE("emu_task", "SPI DEAD â€” aborting emulation!");
        s_emu_done = true;
        vTaskDelete(NULL);
        return;
    }

    /* Test reading target IRQ register once */
    uint8_t tgt_test = 0;
    hb_spi_reg_read(REG_TARGET_INT, &tgt_test);
    ESP_LOGI("emu_task", "Pre-loop TGT_INT=0x%02X â€” SPI works âœ“", tgt_test);

    int64_t start_time = esp_timer_get_time();
    int64_t timeout_us = 60 * 1000000LL;
    mfc_emu_state_t last_state = MFC_EMU_STATE_IDLE;
    int iter = 0;

    while ((esp_timer_get_time() - start_time) < timeout_us) {
        mfc_emu_state_t state = mfc_emu_run_step();

        /* Log state changes */
        if (state != last_state) {
            ESP_LOGI("emu_task", "Estado: %s -> %s",
                     mfc_emu_state_str(last_state),
                     mfc_emu_state_str(state));
            last_state = state;
        }

        /* MUST delay to let IDLE task run on CPU 0 */
        vTaskDelay(1);

        /* Heartbeat â€” now includes field measurement + IRQ state */
        iter++;
        if ((iter % 600) == 0) {
            int elapsed_s = (int)((esp_timer_get_time() - start_time) / 1000000);
            mfc_emu_stats_t live = mfc_emu_get_stats();

            /* Read status WITHOUT disrupting Sense state.
             * NOTE: CMD_MEAS_AMPLITUDE could take chip out of Sense!
             * Instead, just read status registers (non-destructive). */
            uint8_t pt_sts = 0, aux = 0;
            hb_spi_reg_read(REG_PASSIVE_TARGET_STS, &pt_sts);
            hb_spi_reg_read(REG_AUX_DISPLAY, &aux);

            ESP_LOGI("emu_task", "  ... emulando (%ds/60s) auth=%d/%d reads=%d writes=%d | PT=0x%02X AUX=0x%02X [efd=%d osc=%d tgt=%d]",
                     elapsed_s, live.successful_auths, live.total_auths,
                     live.reads_served, live.writes_served,
                     pt_sts, aux,
                     aux & 1, (aux >> 2) & 1, (aux >> 7) & 1);
        }
    }

    mfc_emu_stop();
    s_emu_final_stats = mfc_emu_get_stats();
    s_emu_done = true;

    ESP_LOGI("emu_task", "Emulation task finished");
    vTaskDelete(NULL);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *  Main Application
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void app_main(void)
{
    ESP_LOGI(TAG, "");
    ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    ESP_LOGI(TAG, "â•‘  HIGH BOY NFC â€” ST25R3916 Reader v4              â•‘");
    ESP_LOGI(TAG, "â•‘  Crypto1 + Flipper-level Emulation               â•‘");
    ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    ESP_LOGI(TAG, "");

    /* Initialize NVS for card profile storage */
    nfc_device_init();

    highboy_nfc_config_t cfg = HIGHBOY_NFC_CONFIG_DEFAULT();
    hb_nfc_err_t err = st25r_init(&cfg);
    if (err != HB_NFC_OK) {
        ESP_LOGE(TAG, "Init FAILED: %s (0x%02X)", hb_nfc_err_str(err), err);
        return;
    }

    err = nfc_poller_start();
    if (err != HB_NFC_OK) {
        ESP_LOGE(TAG, "Poller start failed: %s", hb_nfc_err_str(err));
        st25r_deinit();
        return;
    }

    ESP_LOGI(TAG, "  Aproxime um cartÃ£o NFC 13.56 MHz...");
    ESP_LOGI(TAG, "");

    /* â”€â”€ Poll for card â”€â”€ */
    nfc_iso14443a_data_t card = { 0 };
    bool found = false;

    for (int i = 0; i < 50; i++) {
        err = iso14443a_poller_select(&card);
        if (err == HB_NFC_OK) {
            found = true;
            break;
        }
        hb_delay_us(100000);
    }

    if (!found) {
        ESP_LOGW(TAG, "  Nenhum cartÃ£o detectado apÃ³s 5 segundos.");
        nfc_poller_stop();
        st25r_deinit();
        return;
    }

    /* â”€â”€ Card detected â”€â”€ */
    card_type_info_t type_info = identify_card(card.sak, card.atqa);

    char uid_str[32], atqa_str[8];
    hex_str(card.uid, card.uid_len, uid_str, sizeof(uid_str));
    snprintf(atqa_str, sizeof(atqa_str), "%02X %02X", card.atqa[0], card.atqa[1]);

    ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    ESP_LOGI(TAG, "â•‘  ğŸ“Ÿ CARTÃƒO DETECTADO                              â•‘");
    ESP_LOGI(TAG, "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    ESP_LOGI(TAG, "â•‘  Tipo:   %s", type_info.full_name);
    ESP_LOGI(TAG, "â•‘  UID:    %s (%d bytes)", uid_str, card.uid_len);
    ESP_LOGI(TAG, "â•‘  ATQA:   %s", atqa_str);
    ESP_LOGI(TAG, "â•‘  SAK:    0x%02X (0b%d%d%d%d%d%d%d%d)", card.sak,
             (card.sak >> 7) & 1, (card.sak >> 6) & 1, (card.sak >> 5) & 1,
             (card.sak >> 4) & 1, (card.sak >> 3) & 1, (card.sak >> 2) & 1,
             (card.sak >> 1) & 1, card.sak & 1);

    /* Quick manufacturer hint from UID */
    const char* mfr = get_manufacturer_name(card.uid[0]);
    if (mfr) {
        ESP_LOGI(TAG, "â•‘  Chip:   %s", mfr);
    }

    /* Protocol info */
    if (type_info.is_mf_classic) {
        ESP_LOGI(TAG, "â•‘  Proto:  ISO 14443-3A + Crypto1 (proprietÃ¡rio NXP)");
    } else if (type_info.is_mf_ultralight) {
        ESP_LOGI(TAG, "â•‘  Proto:  ISO 14443-3A + Ultralight (3-pass auth)");
    } else if (type_info.is_iso_dep) {
        ESP_LOGI(TAG, "â•‘  Proto:  ISO 14443-4 (T=CL / ISO-DEP)");
    }

    ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    /* â”€â”€ Card-specific operations â”€â”€ */
    if (type_info.is_mf_classic) {
        mf_classic_read_full(&card);
    }
    else if (type_info.is_mf_ultralight) {
        mful_dump_card(&card);
    }
    else if (type_info.is_iso_dep) {
        ESP_LOGI(TAG, "");
        ESP_LOGW(TAG, "  ISO-DEP / DESFire: leitura completa nÃ£o implementada.");
    }
    else {
        ESP_LOGW(TAG, "  Tipo nÃ£o suportado (SAK=0x%02X)", card.sak);
    }

    /* â”€â”€ Stop reader mode â”€â”€ */
    nfc_poller_stop();

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *  EMULATION TEST
     *
     *  If we got a complete dump of a MIFARE Classic card,
     *  switch to emulation mode and act like the card.
     *  Test with a phone (NFC Tools) or Flipper Zero.
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    if (s_emu_data_ready && type_info.is_mf_classic) {
        ESP_LOGI(TAG, "");
        ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        ESP_LOGI(TAG, "â•‘  ğŸ”„ MODO EMULAÃ‡ÃƒO                                â•‘");
        ESP_LOGI(TAG, "â•‘                                                  â•‘");
        ESP_LOGI(TAG, "â•‘  Dump completo obtido!                           â•‘");
        ESP_LOGI(TAG, "â•‘                                                  â•‘");
        ESP_LOGI(TAG, "â•‘  âš¡ RETIRE O CARTÃƒO AGORA!                       â•‘");
        ESP_LOGI(TAG, "â•‘                                                  â•‘");
        ESP_LOGI(TAG, "â•‘  Aguardando 5 segundos...                        â•‘");
        ESP_LOGI(TAG, "â•‘  Depois, aproxime um LEITOR (celular/Flipper).   â•‘");
        ESP_LOGI(TAG, "â•‘  EmulaÃ§Ã£o rodarÃ¡ por 60 segundos.                â•‘");
        ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        ESP_LOGI(TAG, "");

        /* Wait for user to remove card */
        for (int i = 5; i > 0; i--) {
            ESP_LOGI(TAG, "  Iniciando emulaÃ§Ã£o em %d...", i);
            vTaskDelay(pdMS_TO_TICKS(1000));
        }

        /* Initialize emulator with card data */
        hb_nfc_err_t emu_err = mfc_emu_init(&s_emu_card);
        if (emu_err != HB_NFC_OK) {
            ESP_LOGE(TAG, "Emulator init failed: %s", hb_nfc_err_str(emu_err));
            st25r_deinit();
            return;
        }

        /* Set event callback for live status */
        mfc_emu_set_callback(emu_event_handler, NULL);

        /* Save profile to NVS for future use */
        char profile_name[32];
        snprintf(profile_name, sizeof(profile_name), "Card_%02X%02X%02X%02X",
                 s_emu_card.uid[0], s_emu_card.uid[1],
                 s_emu_card.uid[2], s_emu_card.uid[3]);
        hb_nfc_err_t save_err = nfc_device_save(profile_name, &s_emu_card);
        if (save_err == HB_NFC_OK) {
            ESP_LOGI(TAG, "â•‘  ğŸ’¾ Perfil salvo: '%s'                           â•‘", profile_name);
            ESP_LOGI(TAG, "â•‘     (disponÃ­vel para emulaÃ§Ã£o futura via NVS)     â•‘");
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *  DIAGNOSTICS-ONLY MODE (v5.1)
         *
         *  The emulation loop showed 0 activations in 60s.
         *  This means the ST25R3916 isn't detecting the reader's
         *  field or isn't completing anti-collision.
         *
         *  We run comprehensive diagnostics to find the root cause.
         *  After diagnostics, we also try a short emulation run
         *  using the configuration that worked best.
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        ESP_LOGI(TAG, "");
        ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        ESP_LOGI(TAG, "â•‘  ğŸ” MODO DIAGNÃ“STICO + EMULAÃ‡ÃƒO                  â•‘");
        ESP_LOGI(TAG, "â•‘                                                  â•‘");
        ESP_LOGI(TAG, "â•‘  UID: %02X %02X %02X %02X   SAK: 0x%02X                â•‘",
                 s_emu_card.uid[0], s_emu_card.uid[1],
                 s_emu_card.uid[2], s_emu_card.uid[3], s_emu_card.sak);
        ESP_LOGI(TAG, "â•‘                                                  â•‘");
        ESP_LOGI(TAG, "â•‘  Fase 1: DiagnÃ³stico completo (~60s)             â•‘");
        ESP_LOGI(TAG, "â•‘  Fase 2: EmulaÃ§Ã£o com melhor config (60s)        â•‘");
        ESP_LOGI(TAG, "â•‘                                                  â•‘");
        ESP_LOGI(TAG, "â•‘  âš¡ MANTENHA O LEITOR PERTO O TEMPO TODO!       â•‘");
        ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

        /* â”€â”€ FASE 1: DIAGNÃ“STICO â”€â”€ */
        emu_diag_full();

        /* â”€â”€ FASE 2: EMULAÃ‡ÃƒO NORMAL â”€â”€ */
        ESP_LOGI(TAG, "");
        ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        ESP_LOGI(TAG, "â•‘  ğŸ“¡ FASE 2: EMULAÃ‡ÃƒO NORMAL (60s)                â•‘");
        ESP_LOGI(TAG, "â•‘  Usando configure_target() padrÃ£o + run_step()  â•‘");
        ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

        /* Re-initialize emulator (diagnostics may have changed state) */
        emu_err = mfc_emu_init(&s_emu_card);
        if (emu_err != HB_NFC_OK) {
            ESP_LOGE(TAG, "Re-init failed: %s", hb_nfc_err_str(emu_err));
            st25r_deinit();
            return;
        }
        mfc_emu_set_callback(emu_event_handler, NULL);

        /* Configure ST25R3916 for target mode */
        emu_err = mfc_emu_configure_target();
        if (emu_err != HB_NFC_OK) {
            ESP_LOGE(TAG, "Target config failed: %s", hb_nfc_err_str(emu_err));
            st25r_deinit();
            return;
        }

        /* Start listening */
        emu_err = mfc_emu_start();
        if (emu_err != HB_NFC_OK) {
            ESP_LOGE(TAG, "Emulator start failed: %s", hb_nfc_err_str(emu_err));
            st25r_deinit();
            return;
        }

        ESP_LOGI(TAG, "EmulaÃ§Ã£o rodando por 60s...");

        /* Run emulation in dedicated task with WDT unsubscribed */
        s_emu_running = true;
        s_emu_done = false;

        TaskHandle_t emu_task_handle = NULL;
        xTaskCreatePinnedToCore(
            emu_task_func,
            "emu_task",
            8192,
            NULL,
            5,
            &emu_task_handle,
            0
        );

        if (emu_task_handle == NULL) {
            ESP_LOGE(TAG, "Failed to create emulation task!");
        } else {
            while (!s_emu_done) {
                vTaskDelay(100);
            }
        }

        ESP_LOGI(TAG, "");
        ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        ESP_LOGI(TAG, "â•‘  ğŸ“Š ESTATÃSTICAS DA EMULAÃ‡ÃƒO                     â•‘");
        ESP_LOGI(TAG, "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        ESP_LOGI(TAG, "â•‘  AtivaÃ§Ãµes (selecionado):  %3d                   â•‘", s_emu_final_stats.cycles);
        ESP_LOGI(TAG, "â•‘  Auth tentativas:          %3d                   â•‘", s_emu_final_stats.total_auths);
        ESP_LOGI(TAG, "â•‘  Auth sucesso:             %3d                   â•‘", s_emu_final_stats.successful_auths);
        ESP_LOGI(TAG, "â•‘  Auth falha:               %3d                   â•‘", s_emu_final_stats.failed_auths);
        ESP_LOGI(TAG, "â•‘  Reads servidos:           %3d                   â•‘", s_emu_final_stats.reads_served);
        ESP_LOGI(TAG, "â•‘  Writes servidos:          %3d                   â•‘", s_emu_final_stats.writes_served);
        ESP_LOGI(TAG, "â•‘  Writes bloqueados (AC):   %3d                   â•‘", s_emu_final_stats.writes_blocked);
        ESP_LOGI(TAG, "â•‘  Ops de valor (INC/DEC):   %3d                   â•‘", s_emu_final_stats.value_ops);
        ESP_LOGI(TAG, "â•‘  NACKs enviados:           %3d                   â•‘", s_emu_final_stats.nacks_sent);
        ESP_LOGI(TAG, "â•‘  HALTs recebidos:          %3d                   â•‘", s_emu_final_stats.halts);
        ESP_LOGI(TAG, "â•‘  Perda de campo:           %3d                   â•‘", s_emu_final_stats.field_losses);
        ESP_LOGI(TAG, "â•‘  Comandos desconhecidos:   %3d                   â•‘", s_emu_final_stats.unknown_cmds);
        ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    }
    else {
        ESP_LOGI(TAG, "");
        ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        ESP_LOGI(TAG, "â•‘  âœ… Leitura concluÃ­da.                            â•‘");
        if (!s_emu_data_ready) {
            ESP_LOGW(TAG, "â•‘  âš  Dump incompleto â€” emulaÃ§Ã£o nÃ£o disponÃ­vel.   â•‘");
        }
        ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    }

    st25r_deinit();
}
